\documentclass[a4paper,10pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage{listings}

\title{TTP1 - Protokoll}
\author{Andreas Krohn, Benjamin Vetter, Benjamin Jochheim}

\begin{document}

\maketitle

\section{Projektschritt 2: Vergleichende Betrachtung des B.A.T.M.A.N.- und OLSR-Protokolls}

\subsection{Welche Informationen tauschen die Nachbarn bei den jeweiligen Protokollen aus (Neighbor-Nachrichten)?}

% B.A.T.M.A.N.

\subsubsection*{B.A.T.M.A.N.}

Bei B.A.T.M.A.N. werden proaktiv sog. Originator-Nachrichten (OGMs) ausgetauscht.
Eine OGM umfasst folgende Felder: 

\begin{description}
  \item[Version] Versionsnummer.
  \item[Is-direct-link flag] Kennzeichnet, ob der Knoten ein direkter Nachbar ist oder nicht.
  \item[Unidirectional flag] Kennzeichnet, ob der Knoten bidirektional ist oder nicht.
  \item[TTL] der Time-To-Live Wert der OGM.
  \item[GWFlags] Kennzeichnet ob der Originator als Gateway ins Internet fungiert. Ein Originator kann sich selbst als Internet-Gateway annoncieren. Die Annonce beinhaltet die Link-Geschwindigkeit.
  \item[GWPort] Beinhaltet eine Portnummer für einen Tunnel falls sich der Originator als Internet-Gateway annonciert.
  \item[Sequenznummer] Eine Sequenznummer der OGM (0 bis 2\^16-1). Anhand der Sequenznummer können andere Knoten entscheiden ob eine OGM "neu" ist.
  \item[Originator-Adresse] Die IP-Adresse des B.A.T.M.A.N. Interfaces des OGM-Initiators.
\end{description}

Einer OGM können sich Host Network Announcements (HNAs) anschließen. 
HNAs annoncieren ein Gateway zu einem Netzwerk oder Host.
Eine HNA umfasst folgende Felder: 

\begin{description}
  \item[Netmask] Kennzeichnet die Größe des annoncierten Netzes
  \item[Network address] Die Adresse des annoncierten Netzes
\end{description}

% OLSR

\subsubsection*{OLSR}

OLSR verfügt über ein generelles Messageformat.
Nachrichten können konkateniert werden.
Eine einzelne Nachricht besteht aus:

\begin{description}
  \item[Packet Length] Paketlänge.
  \item[Packet Sequence Number] Die Sequenznummer. Erhöht sich bei jeder neuen Nachricht um 1. 
  \item[Message Type] Die Message Type teilt mit um was für eine Nachricht es sich handelt, bzw. was das MESSAGE-Feld enthält.
  \item[Vtime] Die Validity Time teilt mit wie lange die Informationen das Pakets von einem Knoten als aktuell betrachtet werden sollen, sofern keine neuere Nachricht zu einem Update führt.
  \item[Message Size] Größe der Nachricht in Byte. Gezählt wird vom Feld Message Type an bis zum nächsten Message Type Feld (nächste konkaktenierte Nachricht).
  \item[Originator Address] Die Adresse des Knotens, der die Nachricht ursprünglich generiert hat.
  \item[Time To Live] Die maximale Anzahl an Hops. Der Wert wird dekrementiert bevor die Nachricht weitergeleitet wird.
  \item[Hop Count] Die Anzahl an Hops, die die Nachricht zurückgelegt hat.
  \item[Message Sequence Number] Der Originator einer Nachricht erzeugt eine eindeutige ID für jede Nachricht.
  \item[MESSAGE]
\end{description}

Anhand des Message Type Feldes wird festgelegt, welcher Nachrichtentyp im MESSAGE-Block enthalten ist. 
RFC3626 spezifiziert die Nachrichtentypen HELLO, TC, MID und HNA.

\begin{description}
  \item[HELLO] HELLO-Nachrichten erfüllen den Zweck der Veröffentlichung der lokalen Routinginformationen, dem Erkennen von Nachbarn und der Auswahl der Multipoint Relays. Daher werden HELLO-Nachrichten stets periodisch verschickt. Eine HELLO-Nachricht besteht aus einer Liste von bekannten Nachbaradressen und Informationen (Status des Nachbarn) über diese Nachbarn, sowie der eigenen Bereitschaft Pakete weiterzuleiten (Willingness).
  \item[TC] TC-Nachrichten dienen dazu die gewonnen Informationen über die Topologie zu verteilen. TC-Nachrichten werden von MPRs erstellt und beinhalten mindestens die Knoten von denen sie als MPR ausgewählt wurden.
  \item[MID] Knoten, die über mehrere OLSR Interfaces verfügen verschicken MID-Nachrichten um den anderen Knoten ihre Interfacekonfiguration mitzuteilen.
  \item[HNA] Knoten, die über Routinginformationen bzgl. der Außenwelt des MANETs betreffen, verschicken analog zu B.A.T.M.A.N. Host Network Announcement Nachrichten (HNAs).
\end{description}

\subsection{Wie ermitteln/bewerten sie die Qualität der Links}

% B.A.T.M.A.N.

\subsubsection*{B.A.T.M.A.N.}

Erhält ein Knoten schneller und zuverlässiger OGMs von einem Nachbarn kann er diesen Knoten als Best-Next-Hop auswählen um Nachrichten an weiter entfernte Knoten zu verschicken.
Hierzu unterhält jeder Knoten ein Sliding-Window bzgl. der Sequenznummern von OGMs jedes Nachbarn. 
Erhält ein Knoten eine OGM von einem Nachbarn betrachtet er die Sequenznummer der OGM.
Wenn die Sequenznummer im Fenster vorhanden ist, speichert der Knoten diese Information.
Hingegen wird das Fenster verschoben, wenn die Sequenznummer außerhalb des Fensters liegt.
Je mehr Sequenznummern innerhalb des Fensters liegen, desto besser bewertet der Knoten die Link-Qualität.
Der Link, der die meisten Sequenznummern in seinem Fenster aufweisen kann, gilt als aktueller Best-Next-Hop.

% OLSR

\subsubsection*{OLSR}

...RFC lesen..
Link Set über HELLO Messages aufbauen. Eigener Originator in 
empfangener Message enthalten -> Symmetrischer Link. Timeouts -> Asymmetrisch, dann Tot.
Symmetrie eines Links ist ein Indiz für Qualität.. bla..
Signal Noise Ratio -> l\_link\_quality P.57f

Der verwendete OLSR-Daemon nutzte Link Quality Extensions (ETX-metrik).
Das RFC-gemäße OLSR versucht nur die HOP-Distanz zu minimieren. Die Link-Qualität
wird nach RFC nicht berücksichtigt. Das kann bedeuten das ein unzuverlässiger Link zu einem Ziel bevorzugt wird,
wenn er eine geringere HOP-Distanz bietet.

Der um Link Quality Extensions erweiterte OLSR-Daemon wertet die erwarteten und tatsächlich empfangenen
HELLO Pakete seiner direkten Nachbarn aus und kann dadurch die Link-Qualität bestimmen.

http://www.olsr.org/docs/README-Link-Quality.html


\subsection{Wie bilden sich die lokalen Mesh-Konfigurationen?}

% B.A.T.M.A.N.

\subsubsection*{B.A.T.M.A.N.}

B.A.T.M.A.N. ist ein proaktives Routing-Protokoll.
Das Protokoll hat das Ziel für jeden Knoten den jeweils besten Next-Hop zu finden, so dass keine vollständigen Routen verwaltet werden müssen, sondern nur der nächste Hop zum Ziel.
Jeder Knoten broadcastet Originator-Nachrichten (OGMs) periodisch um seine Nachbarn über seine Existenz zu informieren.
Ein Jitter verhindert dabei Kollisionen.
Seine Nachbarn re-broadcasten die OGMs und informieren ihrerseits ihre Nachbarn über die Existenz des eigentlichen Absenders der OGM.
Jeder Knoten re-broadcastet die OGM seines aktuell als Best-Next-Hop identifizierten Knotens, sofern der Knoten die OGM anhand der Sequenznummer als "neu" einstuft und die TTL noch nicht abgelaufen ist.
Beim jedem Re-broadcasting wird der TTL-Wert um 1 verringert.
Daher wird das Netz mit OGMs geflutet.
Eine Verbindung mit einem spezifischen Nachbarn gilt als bidrektional wenn ein Knoten seine eigenen OGMs von diesem Nachbarn empfängt.

% OLSR

\subsubsection*{OLSR}

\subsection{Ist das B.A.T.M.A.N.-Protokoll wirklich immer Loop-frei? Wie könnten sich ggf. Loops bilden?}
Sind mehrere Nodes sowohl per BATMAN als auch per klassischem Ethernet verbunden, kann eine Loop entstehen. Die BATMAN-spezifischen Paketheader werden im Ethernet nicht weitergeleitet, damit die Mechanismen zur Loopverhinderung ausgehebelt....
 Allerdings ist folgendes Szenario denkbar:
Bei schwankender Linkqualität könnte ein Paket mehrfach an einem Host ankommen.
In dem Bild

%figure .eps


möchte Host Z ein Paket an E senden. Dazu wählt er seinen nächsten Hop A aus.
Die beiden Verbindungen zum zielhost sind jedoch von schlechter qualität.
In dem moment in dem das Paket ankommt ist die Verbindung AE zusammengebrochen.
Daher sendet A das Paket an D.
D sendet an C.
In dem moment in dem C das Paket erhält bricht die Verbindung zu E zusammen, so daß C das Paket wieder an A sendet.
%etc.

Bei unseren Versuchen konnten wir solche Loops nicht erzeugen.


\section{Projektschritt 3: Vergleichende Analyse der Übertragungsqualität}

http://openmaniak.com/iperf.php

als erstes mal bandwidth check
==============================

\begin{lstlisting}
server: iperf -s -u # udp server öffnen (ggf -i für periodische ausgabe)
client: iperf -c [IP] -u -i -t [SECONDS] # client zum server per udp connecten und bandwidth check mit periodischer ausgabe
\end{lstlisting}


dann bidirectional bandwidth check:
===================================

\begin{lstlisting}
client: iperf -c [IP] -u -r -i # client zum server per udp connected und bidirectional bandwidth check
\end{lstlisting}

dann simultaneous bidirectional bandwidth check
===============================================

\begin{lstlisting}
client: iperf -c [IP] -u -d
\end{lstlisting}

\subsection{1. Paketverluste (Loss)}

PING
====

zunächst mal ping:

ping [IP] -c 10

IPERF
=====

Datagram loss: can be measured with an Iperf UDP test.

client: iperf -c [IP] -u -d

In der Ausgabe findet sich der Packet-loss

\subsection{2. Paketlaufzeiten / -verzögerungen (Delay)}

http://blogs.itrinegy.com/2009/02/how-do-you-measure-latency-rtt-in-a-network-these-days/

PING
====
Mittels des Pings wird die round-trip-time gemessen.


ping [IP] -c 10

TCPDUMP
=======

Auch mit tcpdump kann die Lantenz gemessen werden, indem die Paketlaufzeiten bei zB TCP-Handshakes (SYN => SYN+ACK) gemessen werden

client:

tcpdump -ni [IF]
...

11:37:07.681274 IP [IP].[PORT] > [IP].[PORT]: Flags [S], ...
11:37:07.682417 IP [IP].[PORT] > [IP].[PORT]: Flags [S.], ...

11:37:07.682417 - 11:37:07.681274

1,143 millis Latenz

\subsection{3. Laufzeitschwankungen (Jitter) der Pakete}

In the context of computer networks, the term jitter is often used as a measure of the variability over time of the packet latency across a network. A network with constant latency has no variation (or jitter).[2] Packet jitter is expressed as an average of the deviation from the network mean latency. However, for this use, the term is imprecise. The standards-based term is packet delay variation (PDV).[3] PDV is an important quality of service factor in assessment of network performance.

The jitter is basically the latency variation and does not depend on the latency

PING
====

ping [IP] -c 10

rtt min/avg/max/mdev = 1.111/1.603/4.820/1.082 ms # Gibt grob über die Varianz der Lantenz Auskunft (eher konstante Latenz oder sehr große Unterschiede in der Latenz)

Die Varianz ist das arithmetische Mittel der quadratischen Abweichungen vom Mittelwert.

bsp für ping:

... time=4.82 ms
... time=1.13 ms
... time=1.19 ms
... time=1.11 ms
... time=1.24 ms
... time=1.17 ms
... time=1.12 ms
... time=1.46 ms
... time=1.57 ms
... time=1.18 ms

def varianz(arr)
  avg = arr.inject(0) { |x, y| x + y } / arr.size.to_f
  q = arr.inject(0) { |x, y| x += (y - avg) * (y - avg) }
  return q / arr.size.to_f
end

TCPDUMP
======

Das gleiche kann man auch per tcpdump machen, ist aber recht aufwendig

IPERF
=====

Jitter (latency variation): can be measured with an Iperf UDP test.

client: iperf -c [IP] -u -d

In der Ausgabe findet sich der Jitter

Methodik:

- Telefonieren und Hopzahl steigern
- Messungen durchführen und Hopzahl steigern
- Telefonieren und dabei messen (iperf) um Netzlast zu erzeugen

1. Telefonieren mit 1 Hop
2. Messen mit 1 Hop
3. Telefonieren und Messen mit 1 Hop mit Erhöhung der Netzlast (-b 0.1m -b 0.5m -b 1m -b 10m -b 100m)

1. Telefonieren mit 2 Hop
2. Messen mit 2 Hop
3. Telefonieren und Messen mit 2 Hop mit Erhöhung der Netzlast (-b 0.1m -b 0.5m -b 1m -b 10m -b 100m)

1. Telefonieren mit 3 Hop
2. Messen mit 3 Hop
3. Telefonieren und Messen mit 3 Hop mit Erhöhung der Netzlast (-b 0.1m -b 0.5m -b 1m -b 10m -b 100m)

Das Messen geschieht folgendermaßen:

server:
iperf -s -u

client:
ping -c 20 [IP] >> ping.txt
iperf -c [IP] -u -b [BANDWIDTH] >> iperf.txt

#!/bin/sh

# USAGE performance.sh [TARGET-IP] [LOGFILE]

echo "NEW RUN `date`" > $2

# PING

echo "RUNNING PING" > $2
echo "RUNNING PING"

ping -c 20 $1 >> $2

# IPERF

for b in 0.1m 0.5m 1m 5m 10m 20m 50m # ggf anpassen
do
  echo "RUNNING IPERF for $b" > $2
  echo "RUNNING IPERF for $b"

  iperf -c $1 -u -b $b > $2
done

\end{document}

